
# VirtualData-simple
![](https://img.shields.io/badge/build-passing-brightgreen.svg)
![](https://img.shields.io/badge/license-MIT-blue.svg)

一种加载超大数据块的解决方案（简单版本，单线程单缓存）

## 场景复现

现有一份写好的代码，内部有个功能是对三维图像数据进行分析，其中对图像数据载入的方式是一次性读取整个图像文件，原来每次使用的图像单个大小都不超过300MB，:relieved:所以程序运行起来没有任何问题，**但是**:flushed:现在使用的图片大小突然暴增，不再使用原来不超过300MB的图片，而是开始使用50GB以上的图像数据，**那么问题来了！**程序还是会一次性加载整个文件，而我们的电脑一般只有8GB内存，那么必然会加载导致失败。

## 解决方案

1. 将三维图像沿x、y、z方向切割成若干份，分别存成单个文件并编号（单个的小文件简称：tmp文件）
2. 框架对外提供一个获取数据的接口```T& GetData(int, int, int)```，用于获取坐标(x, y, z)位置的数据
3. 依据坐标(x, y, z)找出该坐标所在的tmp文件，将绝对坐标(x, y, z)转换成tmp文件内的相对坐标(rx, ry, rz)，并返回tmp文件编号fileID
4. 检查返回的编号fileID与当前加载的缓存数据编号BufferID是否一致；如果一致，则直接返回坐标(rx, ry, rz)的引用；如果不一致，则加载fileID对应的数据，再返回坐标(rx, ry, rz)的引用

## 使用说明

### 数据构造Utils

用于生成测试数据，需要输入四个参数：文件路径、长度、宽度、高度，运行结束后会生成一个二进制文件（默认存储数据为unsinged char类型），该文件模拟的是将超大文件切割后的小文件。

### 操作超大数据

根据坐标输出对应的数据，外部表现和将原超大数据一次性加载入内存进行操作无异，内部表现是始终维持一个tmp文件大小的buffer区，按照坐标加载对应文件进行操作

## 写在最后

通过本框架可实现对超大数据的可行性操作，如读取、写入等，对外仅提供一个数据获取接口，如同操作数组一样简便

**待改进部分：**

本框架为单线程+单缓存区，使用性能表现取决于数据读写的顺序，对于频繁切换缓存区的场景，性能会大幅下降
